"use strict";
// docs: https://nodejs.org/dist/latest-v10.x/docs/api/https.html#https_https_request_url_options_callback
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = void 0;
const fs = __importStar(require("fs"));
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const qs = __importStar(require("querystring"));
const zlib_1 = require("zlib");
const clean_object_1 = require("./lib/clean-object");
const deepmerge_1 = require("./lib/deepmerge");
const native_client_keys_1 = require("./lib/native-client-keys");
const merge_url_1 = require("./lib/merge-url");
const pkg = JSON.parse(fs.readFileSync('./package.json', 'utf-8'));
function request(url, options = {}, formData = null) {
    const [body, dataIsObject] = Object.prototype.toString.call(formData) === '[object Object]'
        ? [qs.stringify(formData), true]
        : [formData, false];
    const mergedOptions = [
        {
            method: 'GET',
            responseType: 'text',
            headers: {
                'User-Agent': `smol-request/${pkg.version}`,
                Accept: '*/*'
            }
        }
    ];
    if (dataIsObject && body) {
        mergedOptions.push({
            headers: { 'Content-Length': Buffer.byteLength(body) }
        });
    }
    if (dataIsObject && typeof body === 'string') {
        mergedOptions.push({
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
    }
    mergedOptions.push(options);
    if (options.responseType && options.responseType === 'buffer') {
        mergedOptions.push({
            headers: { 'Content-Type': 'application/octet-stream' }
        });
    }
    const requestOptions = deepmerge_1.deepmerge(mergedOptions[0], ...mergedOptions.slice(1));
    if (requestOptions.params && typeof requestOptions.params === 'object') {
        url = merge_url_1.mergeUrl(url, requestOptions.params);
    }
    return new Promise((resolve, reject) => {
        const client = url.startsWith('https') ? https : http;
        let resolved = false;
        const result = {
            data: null,
            headers: null,
            status: null,
            statusText: null
        };
        const cleanRequestOptions = clean_object_1.cleanObject(requestOptions, native_client_keys_1.nativeClientKeys);
        const req = client.request(url, cleanRequestOptions);
        req.on('error', onError);
        req.on('response', onResponse);
        req.on('close', onClose);
        if (requestOptions.headers) {
            Object.entries(requestOptions.headers).forEach(([name, value]) => req.setHeader(name, value));
        }
        function onClose() {
            if (resolved) {
                return;
            }
            switch (requestOptions.responseType) {
                case 'buffer': {
                    result.data = Buffer.concat(result.data);
                    break;
                }
                case 'json': {
                    try {
                        result.data = JSON.parse(result.data.join(''));
                    }
                    catch (e) {
                        return reject(new Error(`JSON parsing error: ${e.message}: ${result.data}`));
                    }
                    break;
                }
                default: {
                    if (result.data && Array.isArray(result.data)) {
                        result.data = result.data.join('');
                    }
                    break;
                }
            }
            resolve(result);
        }
        function onError(err) {
            req.removeListener('error', onError);
            reject(err);
        }
        function onResponse(res) {
            result.headers = res.headers;
            result.status = res.statusCode;
            result.statusText = res.statusMessage;
            if (requestOptions.responseType === 'headers') {
                resolved = true;
                return resolve(result);
            }
            const stream = ['gzip', 'compress', 'deflate'].includes(res.headers['content-encoding']) && res.statusCode === 204
                ? res.pipe(zlib_1.createUnzip())
                : res;
            if (requestOptions.responseType === 'stream') {
                result.data = stream;
                resolved = true;
                return resolve(result);
            }
            // stream.setEncoding('utf8')
            const responseData = [];
            const onData = (chunk) => {
                responseData.push(requestOptions.responseType === 'buffer' ? Buffer.from(chunk) : chunk);
            };
            const onError = (err) => {
                stream.removeListener('error', onError);
                stream.removeListener('data', onData);
                reject(err);
            };
            const onRequestEnd = () => {
                stream.removeListener('error', onError);
                stream.removeListener('data', onData);
                stream.removeListener('end', onRequestEnd);
                result.data = responseData;
            };
            stream.on('data', onData);
            stream.on('error', onError);
            stream.on('end', onRequestEnd);
        }
        if (body === null || !body) {
            req.end();
        }
        else if (Buffer.isBuffer(body) || typeof body === 'string') {
            req.write(body);
            req.end();
        }
        else {
            ;
            body.pipe(req);
        }
    });
}
exports.request = request;
